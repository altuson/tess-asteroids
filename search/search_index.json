{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#tess-asteroids","title":"tess-asteroids","text":"<p><code>tess-asteroids</code> allows you to make Target Pixel Files (TPFs) and Light Curve Files (LCFs) for any object that moves through the TESS field of view, for example solar system asteroids, comets or minor planets.</p>"},{"location":"#installation","title":"Installation","text":"<p>The easiest way to install <code>tess-asteroids</code> and all of its dependencies is to run the following command in a terminal window:</p> <pre><code>pip install tess-asteroids\n</code></pre>"},{"location":"#lkspacecraft-dependency","title":"<code>lkspacecraft</code> dependency","text":"<p><code>tess-asteroids</code> uses <code>lkspacecraft</code> to derive barycentric time corrections (see below). The first time you run <code>lkspacecraft</code> it will download a set of files (the SPICE kernels for TESS). This will take approximately 5 minutes, depending on your internet connection, and the total file volume will be about 1GB. The files will be cached once they are downloaded and if a new version of any file becomes available they will be automatically retrieved.</p>"},{"location":"#quickstart","title":"Quickstart","text":"<p>You can easily make and save a TPF and LCF for any object in the JPL Small-Body Database that has been observed by TESS. For example,</p> <pre><code>from tess_asteroids import MovingTPF\n\n# Initialise MovingTPF for asteroid 1980 VR1 in TESS sector 1\ntarget = MovingTPF.from_name(\"1980 VR1\", sector=1, camera=1, ccd=1)\n\n# Make TPF and save to file (tess-1980VR1-s0001-1-1-shape11x11-moving_tp.fits)\ntarget.make_tpf(save=True)\n\n# Make LC and save to file (tess-1980VR1-s0001-1-1-shape11x11_lc.fits)\ntarget.make_lc(save=True)\n</code></pre> <p> </p>"},{"location":"#tutorial","title":"Tutorial","text":""},{"location":"#making-a-tpf","title":"Making a TPF","text":"<p>You can create a TPF that tracks a moving object from the JPL Small-Body Database by providing the object's name and TESS sector:</p> <pre><code>from tess_asteroids import MovingTPF\n\n# Initialise MovingTPF for asteroid 1998 YT6 in TESS sector 6\ntarget = MovingTPF.from_name(\"1998 YT6\", sector=6)\n\n# Make TPF and save to file (tess-1998YT6-s0006-1-1-shape11x11-moving_tp.fits)\ntarget.make_tpf(save=True)\n</code></pre> <p>The <code>make_tpf()</code> function is retrieving and reshaping the FFI data, performing a background correction, computing an aperture and saving a SPOC-like TPF. There are a few optional parameters in the <code>make_tpf()</code> function. This includes:</p> <ul> <li><code>shape</code> controls the shape (nrows,ncols) of the TPF. Default : (11,11).</li> <li><code>bg_method</code> defines the method used to correct the background flux. Default: <code>linear_model</code>.</li> <li><code>ap_method</code> defines the method used to create the aperture. Default: <code>prf</code>.</li> <li><code>save</code> determines whether or not the TPF will be saved as a FITS file. Default: <code>False</code>.</li> <li><code>outdir</code> is the directory where the TPF will be saved. Note, the directory is not automatically created.</li> <li><code>file_name</code> is the name the TPF will be saved with. If one is not given, a default name will be generated.</li> </ul> <p>These settings can be changed as follows:</p> <pre><code># Make TPF and save to file - change default settings\ntarget.make_tpf(shape=(20,10), bg_method=\"rolling\", ap_method=\"threshold\", save=True, file_name=\"test.fits\", outdir=\"movingTPF\")\n</code></pre> <p>A TPF can only be created for a single combination of sector/camera/CCD at a time. If the object crosses multiple cameras or CCDs during a sector, then the camera/CCD must also be specified when initialising <code>MovingTPF()</code>:</p> <pre><code># Initialise MovingTPF for asteroid 2013 OS3 in TESS sector 20\ntarget = MovingTPF.from_name(\"2013 OS3\", sector=20, camera=2, ccd=3)\n</code></pre> <p>You can also initialise <code>MovingTPF()</code> with your own ephemeris:</p> <pre><code>from tess_asteroids import MovingTPF\nimport numpy as np\nimport pandas as pd\n\n# Create an artificial ephemeris\ntime = np.linspace(1790.5, 1795.5, 100)\nephem = pd.DataFrame({\n            \"time\": time,\n            \"sector\": np.full(len(time), 18),\n            \"camera\": np.full(len(time), 3),\n            \"ccd\": np.full(len(time), 2),\n            \"column\": np.linspace(500, 600, len(time)),\n            \"row\": np.linspace(1000, 900, len(time)),\n        })\n\n# Initialise MovingTPF\ntarget = MovingTPF(\"example\", ephem, time_scale = \"tdb\")\n\n# Make TPF, but do not save to file\ntarget.make_tpf()\n</code></pre> <p>A few things to note about the format of the ephemeris:</p> <ul> <li><code>time</code> must have units JD - 2457000. See explanation of <code>time_scale</code> below.</li> <li><code>sector</code>, <code>camera</code>, <code>ccd</code> must each have one unique value.</li> <li><code>column</code>, <code>row</code> must be one-indexed, where the lower left pixel of the FFI has value (1,1).</li> </ul>"},{"location":"#animating-the-tpf","title":"Animating the TPF","text":"<p><code>animate_tpf()</code> is a built-in helper function to plot the TPF and aperture over time:</p> <pre><code>from tess_asteroids import MovingTPF\n\n# Initialise MovingTPF for asteroid 1998 YT6 in TESS sector 6\ntarget = MovingTPF.from_name(\"1998 YT6\", sector=6)\n\n# Make TPF, but do not save to file\ntarget.make_tpf()\n\n# Animate TPF and save to file (tess-1998YT6-s0006-1-1-shape11x11-moving_tp.gif)\ntarget.animate_tpf(save=True)\n</code></pre>"},{"location":"#making-a-lc","title":"Making a LC","text":"<p>You can extract a LC from the TPF, using aperture photometry, as follows:</p> <pre><code>from tess_asteroids import MovingTPF\n\n# Initialise MovingTPF for asteroid 1998 YT6 in TESS sector 6\ntarget = MovingTPF.from_name(\"1998 YT6\", sector=6)\n\n# Make TPF and save to file (tess-1998YT6-s0006-1-1-shape11x11-moving_tp.fits)\ntarget.make_tpf(save=True)\n\n# Make LC and save to file (tess-1998YT6-s0006-1-1-shape11x11_lc.fits)\ntarget.make_lc(save=True)\n</code></pre> <p>The <code>make_lc()</code> function extracts the lightcurve, creates a quality mask and optionally saves the LCF. There are a few optional parameters in the <code>make_lc()</code> function. This includes:</p> <ul> <li><code>method</code> defines the method used to perform photometry. Default: <code>aperture</code>.</li> <li><code>save</code> determines whether or not the LCF will be saved as a FITS file. Default: <code>False</code>.</li> <li><code>outdir</code> is the directory where the LCF will be saved. Note, the directory is not automatically created.</li> <li><code>file_name</code> is the name the LCF will be saved with. If one is not given, a default name will be generated.</li> </ul>"},{"location":"#compatibility-with-lightkurve","title":"Compatibility with <code>lightkurve</code>","text":"<p>The TPFs and LCFs that get created by <code>tess-asteroids</code> can be opened with <code>lightkurve</code>, as follows:</p> <pre><code>import lightkurve as lk\n\n# Read in TPF and LCF, without removing bad cadences\ntpf = lk.TessTargetPixelFile(\"tess-1998YT6-s0006-1-1-shape11x11-moving_tp.fits\", quality_bitmask=\"none\")\nlc = lk.io.tess.read_tess_lightcurve(\"tess-1998YT6-s0006-1-1-shape11x11_lc.fits\", quality_bitmask=\"none\")\n\n# Plot TPF and aperture for a single frame\ntpf.plot(aperture_mask=tpf.hdu[3].data[\"APERTURE\"][200], frame=200)\n\n# Plot LC\nlc.plot()\n</code></pre>"},{"location":"#time-scales","title":"Time scales","text":"<p>When you initialise <code>MovingTPF()</code>, the <code>time_scale</code> parameter defines the scale of the <code>time</code> column in the input ephemeris. It can have one of two values:</p> <ul> <li><code>tdb</code> (default): this means the input ephemeris <code>time</code> is in TDB measured at the solar system barycenter. This is the scale used for the TSTART/TSTOP keywords in SPOC FFI headers and the TIME column in SPOC TPFs and LCFs. It is the standard time scale for TESS data products.</li> <li><code>utc</code>: this means the input ephemeris <code>time</code> is in UTC measured at the spacecraft. This can be recovered from the SPOC data products: for FFIs subtract header keyword BARYCORR from TSTART/TSTOP and for TPFs/LCFs subtract the TIMECORR column from the TIME column.</li> </ul> <p>When <code>MovingTPF()</code> is initialised <code>from_name()</code>, the <code>time_scale</code> is handled internally. As a user, you will only need to consider the <code>time_scale</code> if you are inputting a custom ephemeris. </p> <p>For more information about time scales, see the <code>astropy</code> documentation.</p>"},{"location":"#barycentric-time-correction","title":"Barycentric time correction","text":"<p>The barycentric time correction derived by SPOC (BARYCORR) is used to transform the time in UTC at the spacecraft into the time in TDB at the solar system barycenter. This correction is calculated at the center of each FFI (i.e. one correction for each CCD) but, in reality, the correction depends upon RA and Dec. Therefore, within <code>tess-asteroids</code> we use <code>lkspacecraft</code> to re-derive the barycentric time correction based upon the position of the moving target. In the output TPFs and LCFs, you will see columns called ORIGINAL_TIME (FFI timestamp in TDB at barycenter, as derived by SPOC), ORIGINAL_TIMECORR (correction to transform UTC at spacecraft into TDB at barycenter, as derived by SPOC), TIME (re-derived time in TDB at barycenter) and TIMECORR (re-derived time correction).</p>"},{"location":"#understanding-the-tpf-and-lcf","title":"Understanding the TPF and LCF","text":"<p>The TPF has four HDUs: </p> <ul> <li>\"PRIMARY\" - a primary HDU containing only a header.</li> <li>\"PIXELS\" - a table with the same columns as a SPOC TPF. Note that \"POS_CORR1\" and \"POS_CORR2\" are defined as the offset between the center of the TPF and the expected position of the moving object given the input ephemeris. </li> <li>\"APERTURE\" - an image HDU containing the average aperture across all times.</li> <li>\"EXTRAS\" - a table HDU containing columns not found in a SPOC TPF. This includes \"RA_PRED\"/\"DEC_PRED\" (expected position of target in world coordinates), \"CORNER1\"/\"CORNER2\" (original FFI column/row of the lower-left pixel in the TPF), \"PIXEL_QUALITY\" (3D pixel quality mask identifying e.g. strap columns, non-science pixels and saturation), \"APERTURE\" (aperture as a function of time) and \"ORIGINAL_TIME\"/\"ORIGINAL_TIMECORR\" (time and barycentric correction derived by SPOC).</li> </ul> <p>The LCF has two HDUs: </p> <ul> <li>\"PRIMARY\" - a primary HDU containing only a header.</li> <li>\"LIGHTCURVE\" - a table HDU with columns including \"TIME\" (timestamps in BTJD), \"FLUX\"/\"FLUX_ERR\" (flux and error from aperture photometry) and \"TESSMAG\"/\"TESSMAG_ERR\" (measured TESS magnitude and error).</li> </ul>"},{"location":"movingtpf/","title":"<code>MovingTPF</code>","text":""},{"location":"movingtpf/#src.tess_asteroids.MovingTPF","title":"MovingTPF","text":"<pre><code>MovingTPF(\n    target: str,\n    ephem: DataFrame,\n    time_scale: str = \"tdb\",\n    metadata: dict = {},\n)\n</code></pre> <p>Create a TPF for a moving target (e.g. asteroid) from a TESS FFI. Includes methods to efficiently retrieve the data, correct the background, define an aperture mask and save a TPF in the SPOC format.</p> <p>Extract a lightcurve from the TPF, using <code>aperture</code> or <code>psf</code> photometry. Includes methods to create quality flags and save the lightcurve as a FITS file.</p> <p>Parameters:</p> <ul> <li> <code>target</code>               (<code>str</code>)           \u2013            <p>Target ID. This is only used when saving the TPF.</p> </li> <li> <code>ephem</code>               (<code>DataFrame</code>)           \u2013            <p>Target ephemeris with columns ['time', 'sector', 'camera', 'ccd', 'column', 'row']. Optional columns: ['vmag', 'hmag'].</p> <ul> <li>'time' : float in format (JD - 2457000). See also <code>time_scale</code> below.</li> <li>'sector', 'camera', 'ccd' : int</li> <li>'column', 'row' : float. These must be one-indexed, where the lower left pixel of the FFI is (1,1).</li> <li>'vmag' : float, optional. Visual magnitude.</li> <li>'hmag' : float, optional. Absolute magnitude.</li> </ul> </li> <li> <code>time_scale</code>               (<code>str</code>, default:                   <code>'tdb'</code> )           \u2013            <p>Time scale of input <code>ephem['time']</code>. One of ['tdb', 'utc']. Default is 'tdb'.</p> <ul> <li>If 'tdb', the input <code>ephem['time']</code> must be in TDB measured at the solar system barycenter from the TESS FFI header.     This is the scale used for the 'TSTART'/'TSTOP' keywords in SPOC FFI headers and the 'TIME' column in SPOC     TPFs and LCFs.</li> <li>If 'utc', the input <code>ephem['time']</code> must be in UTC measured at the spacecraft. This can be recovered from the SPOC data     products: for FFIs subtract header keyword 'BARYCORR' from 'TSTART'/'TSTOP' and for TPFs/LCFs subtract the     'TIMECORR' column from the 'TIME' column.</li> </ul> </li> <li> <code>metadata</code>               (<code>dict</code>, default:                   <code>{}</code> )           \u2013            <p>A dictionary with optional keys {'eccentricity': float, 'inclination': float, 'perihelion': float}.</p> <ul> <li>'eccentricity' : Target's orbital eccentricity. This is saved in the TPF/LCF headers.</li> <li>'inclination' : Target's orbital inclination, in degrees. This is saved in the TPF/LCF headers.</li> <li>'perihelion' : Target's perihelion distance, in AU. This is saved in the TPF/LCF headers.</li> </ul> </li> </ul>"},{"location":"movingtpf/#src.tess_asteroids.MovingTPF.from_name","title":"from_name  <code>staticmethod</code>","text":"<pre><code>from_name(\n    target: str,\n    sector: int,\n    camera: Optional[int] = None,\n    ccd: Optional[int] = None,\n    time_step: float = 0.1,\n)\n</code></pre> <p>Initialises MovingTPF from target name and TESS sector. Uses JPL/Horizons to retrieve ephemeris of target. Specifying a camera and CCD will only use the ephemeris from that camera/ccd.</p> <p>Parameters:</p> <ul> <li> <code>target</code>               (<code>str</code>)           \u2013            <p>JPL/Horizons target ID of e.g. asteroid, comet.</p> </li> <li> <code>sector</code>               (<code>int</code>)           \u2013            <p>TESS sector number.</p> </li> <li> <code>camera</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>TESS camera. Must be defined alongside <code>ccd</code>. If <code>None</code>, full ephemeris will be used to initialise MovingTPF.</p> </li> <li> <code>ccd</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>TESS CCD. Must be defined alongside <code>camera</code>. If <code>None</code>, full ephemeris will be used to initialise MovingTPF.</p> </li> <li> <code>time_step</code>               (<code>float</code>, default:                   <code>0.1</code> )           \u2013            <p>Resolution of ephemeris, in days.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>MovingTPF</code>          \u2013            <p>Initialised MovingTPF with ephemeris and orbital elements from JPL/Horizons. Target ephemeris has columns ['time', 'sector', 'camera', 'ccd', 'column', 'row', 'vmag', 'hmag'].</p> <ul> <li>'time' : float with units (JD - 2457000) in UTC at spacecraft.</li> <li>'sector', 'camera', 'ccd' : int</li> <li>'column', 'row' : float. These are one-indexed, where the lower left pixel of the FFI is (1,1).</li> <li>'vmag' : float. Visual magnitude.</li> <li>'hmag' : float. Absolute magntiude.</li> </ul> </li> </ul>"},{"location":"movingtpf/#src.tess_asteroids.MovingTPF.make_tpf","title":"make_tpf","text":"<pre><code>make_tpf(\n    shape: Tuple[int, int] = (11, 11),\n    bg_method: str = \"linear_model\",\n    ap_method: str = \"prf\",\n    save: bool = False,\n    outdir: str = \"\",\n    file_name: Optional[str] = None,\n    **kwargs,\n)\n</code></pre> <p>Performs all steps to create and save a SPOC-like TPF for a moving target.</p> <p>Parameters:</p> <ul> <li> <code>shape</code>               (<code>Tuple(int, int)</code>, default:                   <code>(11, 11)</code> )           \u2013            <p>Defined as (nrows,ncols), in pixels. Defines the pixels that will be retrieved, centred on the target, at each timestamp.</p> </li> <li> <code>bg_method</code>               (<code>str</code>, default:                   <code>'linear_model'</code> )           \u2013            <p>Method used for background correction. One of [<code>rolling</code>, <code>linear_model</code>].</p> </li> <li> <code>ap_method</code>               (<code>str</code>, default:                   <code>'prf'</code> )           \u2013            <p>Method used to create aperture. One of [<code>threshold</code>, <code>prf</code>, <code>ellipse</code>].</p> </li> <li> <code>save</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, save the TPF HDUList to a FITS file.</p> </li> <li> <code>outdir</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>If <code>save</code>, this is the directory into which the file will be saved.</p> </li> <li> <code>file_name</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>If <code>save</code>, this is the filename that will be used. Format must be '.fits'. If no filename is given, a default one will be generated.</p> </li> <li> <code>**kwargs</code>           \u2013            <p>Keyword arguments passed to <code>create_pixel_quality()</code>, <code>background_correction()</code>, <code>create_aperture()</code> and <code>to_fits()</code>.</p> </li> </ul>"},{"location":"movingtpf/#src.tess_asteroids.MovingTPF.make_lc","title":"make_lc","text":"<pre><code>make_lc(\n    method: str = \"aperture\",\n    save: bool = False,\n    file_name: Optional[str] = None,\n    outdir: str = \"\",\n    **kwargs,\n)\n</code></pre> <p>Performs all steps to create a lightcurve from the moving TPF, with the option to save.</p> <p>Parameters:</p> <ul> <li> <code>method</code>               (<code>str</code>, default:                   <code>'aperture'</code> )           \u2013            <p>Method to extract lightcurve. One of [<code>aperture</code>, <code>psf</code>].</p> </li> <li> <code>save</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, save the lightcurve HDUList to a FITS file.</p> </li> <li> <code>outdir</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>If <code>save</code>, this is the directory into which the file will be saved.</p> </li> <li> <code>file_name</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>If <code>save</code>, this is the filename that will be used. Format must be '.fits'. If no filename is given, a default one will be generated.</p> </li> <li> <code>**kwargs</code>           \u2013            <p>Keyword arguments passed to <code>to_lightcurve()</code> and <code>to_fits()</code>.</p> </li> </ul>"},{"location":"movingtpf/#src.tess_asteroids.MovingTPF.get_data","title":"get_data","text":"<pre><code>get_data(shape: Tuple[int, int] = (11, 11))\n</code></pre> <p>Retrieve pixel data for a moving target from a TESS FFI.</p> <p>Parameters:</p> <ul> <li> <code>shape</code>               (<code>Tuple(int, int)</code>, default:                   <code>(11, 11)</code> )           \u2013            <p>Defined as (nrows,ncols), in pixels. Defines the pixels that will be retrieved, centred on the target, at each timestamp.</p> </li> </ul>"},{"location":"movingtpf/#src.tess_asteroids.MovingTPF.reshape_data","title":"reshape_data","text":"<pre><code>reshape_data()\n</code></pre> <p>Reshape flux data into cube with shape (len(self.time), self.shape).</p>"},{"location":"movingtpf/#src.tess_asteroids.MovingTPF.background_correction","title":"background_correction","text":"<pre><code>background_correction(\n    method: str = \"linear_model\", **kwargs\n)\n</code></pre> <p>Apply background correction to reshaped flux data.</p> <p>Parameters:</p> <ul> <li> <code>method</code>               (<code>str</code>, default:                   <code>'linear_model'</code> )           \u2013            <p>Method used for background correction. One of [<code>rolling</code>, <code>linear_model</code>].</p> </li> <li> <code>**kwargs</code>           \u2013            <p>Keyword arguments passed to <code>_bg_rolling_median()</code> and <code>_bg_linear_model()</code>.</p> </li> </ul>"},{"location":"movingtpf/#src.tess_asteroids.MovingTPF.create_aperture","title":"create_aperture","text":"<pre><code>create_aperture(method: str = 'prf', **kwargs)\n</code></pre> <p>Creates an aperture mask using method <code>threshold</code>, <code>prf</code> or <code>ellipse</code>. It creates the <code>self.aperture_mask</code> attribute with the 3D mask.</p> <p>Parameters:</p> <ul> <li> <code>method</code>               (<code>str</code>, default:                   <code>'prf'</code> )           \u2013            <p>Method used for aperture estimation. One of [<code>threshold</code>, <code>prf</code>, <code>ellipse</code>].</p> </li> <li> <code>kwargs</code>               (<code>dict</code>, default:                   <code>{}</code> )           \u2013            <p>Keywords arguments passed to aperture mask method, e.g <code>self._create_threshold_mask</code> takes <code>threshold</code> and <code>reference_pixel</code>.</p> </li> </ul>"},{"location":"movingtpf/#src.tess_asteroids.MovingTPF.create_pixel_quality","title":"create_pixel_quality","text":"<pre><code>create_pixel_quality(\n    sat_level: float = 100000.0,\n    sat_buffer_rad: int = 1,\n    **kwargs,\n)\n</code></pre> <p>Create a 3D pixel quality mask. The mask is a bit-wise combination of the following flags (Bit - Description):</p> <ul> <li>1 - pixel is outside of science array</li> <li>2 - pixel is in a strap column</li> <li>3 - pixel is saturated</li> <li>4 - pixel is within <code>sat_buffer_rad</code> pixels of a saturated pixel</li> <li>5 - pixel has no scattered light correction. Only relevant if <code>linear_model</code> background correction was used.</li> <li>6 - pixel had no background linear model, value was infilled. Only relevant if <code>linear_model</code> background correction was used.</li> <li>7 - pixel had negative flux value BEFORE background correction was applied.     This can happen near bleed columns from saturated stars (e.g. see Sector 6, Camera 1, CCD 4).</li> </ul> <p>Parameters:</p> <ul> <li> <code>sat_level</code>               (<code>float</code>, default:                   <code>100000.0</code> )           \u2013            <p>Flux (e-/s) above which to consider a pixel saturated.</p> </li> <li> <code>sat_buffer_rad</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>Approximate radius of saturation buffer (in pixels) around each saturated pixel.</p> </li> </ul>"},{"location":"movingtpf/#src.tess_asteroids.MovingTPF.to_lightcurve","title":"to_lightcurve","text":"<pre><code>to_lightcurve(method: str = 'aperture', **kwargs)\n</code></pre> <p>Extract lightcurve from the moving TPF, using either <code>aperture</code> or <code>psf</code> photometry. This function creates the <code>self.lc</code> attribute, which stores the time series data.</p> <p>Parameters:</p> <ul> <li> <code>method</code>               (<code>str</code>, default:                   <code>'aperture'</code> )           \u2013            <p>Method to extract lightcurve. One of <code>aperture</code> or <code>psf</code>.</p> </li> <li> <code>kwargs</code>               (<code>dict</code>, default:                   <code>{}</code> )           \u2013            <p>Keyword arguments, e.g <code>self._aperture_photometry</code> takes <code>bad_bits</code>.</p> </li> </ul>"},{"location":"movingtpf/#src.tess_asteroids.MovingTPF.to_fits","title":"to_fits","text":"<pre><code>to_fits(\n    file_type: str,\n    save: bool = False,\n    overwrite: bool = True,\n    outdir: str = \"\",\n    file_name: Optional[str] = None,\n    **kwargs,\n)\n</code></pre> <p>Convert the moving TPF or lightcurve data to FITS format. This function creates the <code>self.tpf_hdulist</code> or <code>self.lc_hdulist</code> attribute, which can be optionally saved to a file.</p> <p>Parameters:</p> <ul> <li> <code>file_type</code>               (<code>str</code>)           \u2013            <p>Type of file to be converted to FITS. One of [<code>tpf</code>, <code>lc</code>].</p> </li> <li> <code>save</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, write the HDUList to a file.</p> </li> <li> <code>overwrite</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If <code>save</code>, this determines whether to overwrite an existing file with the same name.</p> </li> <li> <code>outdir</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>If <code>save</code>, this is the directory into which the file will be saved.</p> </li> <li> <code>file_name</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>If <code>save</code>, this is the filename that will be used. Format must be '.fits'. If no filename is given, a default one will be generated.</p> </li> </ul>"},{"location":"movingtpf/#src.tess_asteroids.MovingTPF.animate_tpf","title":"animate_tpf","text":"<pre><code>animate_tpf(\n    show_aperture: bool = True,\n    show_ephemeris: bool = True,\n    step: Optional[int] = None,\n    save: bool = False,\n    outdir: str = \"\",\n    file_name: Optional[str] = None,\n    **kwargs,\n)\n</code></pre> <p>Plot animation of TPF data with optional information overlay.</p> <p>Parameters:</p> <ul> <li> <code>show_aperture</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, the aperture used for photometry is displayed in the animation.</p> </li> <li> <code>show_ephemeris</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, the predicted position of the target is included in the animation.</p> </li> <li> <code>step</code>               (<code>int or None</code>, default:                   <code>None</code> )           \u2013            <p>Spacing between frames, i.e. plot every nth frame.  If <code>None</code>, the spacing will be determined such that about 50 frames are shown. Showing more frames will increase the runtime and, if <code>save</code>, the file size.</p> </li> <li> <code>save</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, save the animation.</p> </li> <li> <code>outdir</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>If <code>save</code>, this is the directory into which the file will be saved.</p> </li> <li> <code>file_name</code>               (<code>str or None</code>, default:                   <code>None</code> )           \u2013            <p>If <code>save</code>, this is the filename that will be used. Format must be '.gif'. If no filename is given, a default one will be generated.</p> </li> <li> <code>kwargs</code>           \u2013            <p>Keyword arguments passed to <code>utils.animate_cube</code> such as <code>interval</code>, <code>repeat_delay</code>, <code>cnorm</code>, <code>vmin</code>, <code>vmax</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>animation</code> (              <code>html</code> )          \u2013            <p>If in a notebook environment, the animation is returned in HTML format for display purposes.</p> </li> </ul>"},{"location":"utils/","title":"<code>utils</code>","text":""},{"location":"utils/#src.tess_asteroids.utils","title":"utils","text":"<p>Utility functions</p>"},{"location":"utils/#src.tess_asteroids.utils.calculate_TESSmag","title":"calculate_TESSmag","text":"<pre><code>calculate_TESSmag(\n    flux: Union[float, ndarray],\n    flux_err: Union[float, ndarray],\n    flux_fraction: Union[float, ndarray],\n)\n</code></pre> <p>Calculate TESS magnitude from a flux and a zero-point magnitude. The equation was taken from the TESS Instrument Handbook 2018 (see also Fausnaugh et al. 2021).</p> <p>This function assumes that the background flux has been perfectly removed, i.e. the only flux is that from the target. It can account for flux outside of the aperture via <code>flux_fraction</code>.</p> <p>Parameters:</p> <ul> <li> <code>flux</code>               (<code>float or ndarray</code>)           \u2013            <p>Target flux, in electrons/second.</p> </li> <li> <code>flux_err</code>               (<code>float or ndarray</code>)           \u2013            <p>Error on target flux, in electrons/second.</p> </li> <li> <code>flux_fraction</code>               (<code>float or ndarray</code>)           \u2013            <p>Fraction of target flux inside aperture. Must satisfy: 0 &lt; <code>flux_fraction</code> &lt;= 1.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>mag</code> (              <code>float or ndarray</code> )          \u2013            <p>TESS magnitude.</p> </li> <li> <code>mag_err</code> (              <code>float or ndarray</code> )          \u2013            <p>Error on TESS magnitude.</p> </li> </ul>"},{"location":"utils/#src.tess_asteroids.utils.compute_moments","title":"compute_moments","text":"<pre><code>compute_moments(\n    flux: ndarray,\n    mask: Optional[ndarray] = None,\n    second_order: bool = True,\n    return_err: bool = False,\n)\n</code></pre> <p>Computes first and second order moments of a 2d distribution over time using a coordinate grid with the same shape as <code>flux</code> (nt, nrows, ncols). First order moments (X,Y) are the centroid positions. The X,Y centroids are in the range [0, ncols), [0, nrows), respectively i.e. they are zero-indexed. Second order moments (X2, Y2, XY) represent the spatial spread of the distribution.</p> <p>Parameters:</p> <ul> <li> <code>flux</code>               (<code>ndarray</code>)           \u2013            <p>3D array with flux values as (nt, nrows, ncols).</p> </li> <li> <code>mask</code>               (<code>Optional[ndarray]</code>, default:                   <code>None</code> )           \u2013            <p>Mask to select pixels used for computing moments. Shape could be 3D (nt, nrows, ncols) or 2D (nrows, ncols). If a 2D mask is given, it is used for all frames.</p> </li> <li> <code>second_order</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, returns first and second order moments, else returns only first order moments.</p> </li> <li> <code>return_err</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, returns error on first order moments.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>X, Y, XERR, YERR, X2, Y2, XY: ndarrays</code>           \u2013            <p>First (X, Y) and second (X2, Y2, XY) order moments, plus error on first order moments (XERR, YERR). If <code>second_order</code> is False, X2/Y2/XY are not returned. If <code>return_err</code> is False, XERR/YERR are not returned. Each array has shape (nt).</p> </li> </ul>"},{"location":"utils/#src.tess_asteroids.utils.plot_img_aperture","title":"plot_img_aperture","text":"<pre><code>plot_img_aperture(\n    img: ndarray,\n    aperture_mask: Optional[ndarray] = None,\n    cbar: bool = True,\n    ax: Optional[Axes] = None,\n    corner: Tuple[int, int] = (0, 0),\n    marker: Optional[Tuple[float, float]] = None,\n    title: str = \"\",\n    vmin: Optional[float] = None,\n    vmax: Optional[float] = None,\n    cnorm: Optional[Normalize] = None,\n)\n</code></pre> <p>Plots an image with an optional aperture mask.</p> <p>This function displays an image, optionally overlaying an aperture mask, and provides several customization options such as color scaling, title, and axis control.</p> <p>Parameters:</p> <ul> <li> <code>img</code>               (<code>2D array</code>)           \u2013            <p>The image data to be plotted, typically a 2D array or matrix representing pixel values.</p> </li> <li> <code>aperture_mask</code>               (<code>2D array</code>, default:                   <code>None</code> )           \u2013            <p>A binary mask (same shape as <code>img</code>) indicating the aperture region to be overlaid on the image.</p> </li> <li> <code>cbar</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to display a color bar alongside the plot.</p> </li> <li> <code>ax</code>               (<code>Axes</code>, default:                   <code>None</code> )           \u2013            <p>The axes object where the plot will be drawn. If not provided, a new axes will be created.</p> </li> <li> <code>corner</code>               (<code>list of two ints</code>, default:                   <code>[0, 0]</code> )           \u2013            <p>The (row, column) coordinates of the lower left corner of the image.</p> </li> <li> <code>marker</code>               (<code>tuple of float</code>, default:                   <code>None</code> )           \u2013            <p>The (row, column) coordinates at which to plot a marker in the figure. This can be used to plot the position of the moving object.</p> </li> <li> <code>title</code>               (<code>str</code>, default:                   <code>\"\"</code> )           \u2013            <p>Title of the plot. If None, no title will be shown.</p> </li> <li> <code>vmin</code>               (<code>float</code>, default:                   <code>None</code> )           \u2013            <p>Minimum value for color scale. If None, the 3%-percentile is used.</p> </li> <li> <code>vmax</code>               (<code>float</code>, default:                   <code>None</code> )           \u2013            <p>Maximum value for color scale. If None, the 97%-percentile is used.</p> </li> <li> <code>cnorm</code>               (<code>optional</code>, default:                   <code>None</code> )           \u2013            <p>Color matplotlib normalization object (e.g. astropy.visualization.simple_norm). If provided, then <code>vmax</code> and <code>vmin</code> are not used.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ax</code> (              <code>Axes</code> )          \u2013            <p>The axes object containing the plot.</p> </li> </ul>"},{"location":"utils/#src.tess_asteroids.utils.animate_cube","title":"animate_cube","text":"<pre><code>animate_cube(\n    cube: ndarray,\n    aperture_mask: Optional[ndarray] = None,\n    corner: Union[Tuple, ndarray] = (0, 0),\n    ephemeris: Optional[ndarray] = None,\n    cadenceno: Optional[ndarray] = None,\n    time: Optional[ndarray] = None,\n    interval: int = 200,\n    repeat_delay: int = 1000,\n    step: int = 1,\n    vmin: Optional[float] = None,\n    vmax: Optional[float] = None,\n    cnorm: bool = False,\n    suptitle: str = \"\",\n)\n</code></pre> <p>Creates an animated visualization of a 3D image cube, with an optional aperture mask and other customization options.</p> <p>This function animates the slices of a 3D image cube, optionally overlaying an aperture mask, and provides controls for animation speed, title, and tracking information.</p> <p>Parameters:</p> <ul> <li> <code>cube</code>               (<code>3D array</code>)           \u2013            <p>A 3D array representing the image cube (e.g., a stack of 2D images over time).</p> </li> <li> <code>aperture_mask</code>               (<code>2D or 3D array</code>, default:                   <code>None</code> )           \u2013            <p>A binary mask (same shape or a 2D slice of <code>cube</code>) to overlay on each frame of the animation. If a 2D mask is passed, it will be repeated for all times.</p> </li> <li> <code>corner</code>               (<code>list of two ints or 2D array</code>, default:                   <code>[0, 0]</code> )           \u2013            <p>The (row, column) coordinates of the lower left corner of the image.</p> </li> <li> <code>ephemeris</code>               (<code>2D array</code>, default:                   <code>None</code> )           \u2013            <p>A 2D array of object positions (row, column) to be displayed on the plot. For proper display of object position, if <code>corner</code> is [0, 0] then <code>ephemeris</code> needs to be relative to <code>corner</code>. If <code>corner</code> is provided, <code>ephemeris</code> needs to be absolute. If None, no tracking information is shown.</p> </li> <li> <code>cadenceno</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>The cadence number of the frames, used for information display.</p> </li> <li> <code>time</code>               (<code>array - like</code>, default:                   <code>None</code> )           \u2013            <p>Array of time values corresponding to the slices in the cube.</p> </li> <li> <code>interval</code>               (<code>int</code>, default:                   <code>200</code> )           \u2013            <p>The time interval (in milliseconds) between each frame of the animation.</p> </li> <li> <code>repeat_delay</code>               (<code>int</code>, default:                   <code>1000</code> )           \u2013            <p>The time delay (in milliseconds) before the animation restarts once it finishes.</p> </li> <li> <code>step</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>Spacing between frames, i.e. plot every nth frame.</p> </li> <li> <code>vmin</code>               (<code>float</code>, default:                   <code>None</code> )           \u2013            <p>Minimum value for color scale. If None, the 3%-percentile is used.</p> </li> <li> <code>vmax</code>               (<code>float</code>, default:                   <code>None</code> )           \u2013            <p>Maximum value for color scale. If None, the 97%-percentile is used.</p> </li> <li> <code>cnorm</code>               (<code>optional</code>, default:                   <code>False</code> )           \u2013            <p>Whether to use asinh color normalization (from astropy.visualization.simple_norm). This can be useful for cases when the moving object is too faint compared to other features in the background. If provided, then <code>vmax</code> and <code>vmin</code> are not used.</p> </li> <li> <code>suptitle</code>               (<code>str</code>, default:                   <code>\"\"</code> )           \u2013            <p>A string to be used as the super title of the animation. It can be used to provide additional context or information about the animated data, for example the target name or observing sector/camera/ccd.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ani</code> (              <code>FuncAnimation</code> )          \u2013            <p>The animation object that can be displayed or saved.</p> </li> </ul>"}]}